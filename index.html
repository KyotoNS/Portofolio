<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Flight</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0b0217;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
        }
        canvas {    
            display: block;
            cursor: default;
        }
        #mainSceneCanvas {
            display: none; /* Awalnya disembunyikan */
        }
        .info {
            position: absolute;
            top: 20px;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: none; /* Awalnya disembunyikan */
        }
    </style>
</head>
<body>
    <canvas id="sceneCanvas"></canvas>
    <canvas id="mainSceneCanvas"></canvas>
    <div id="infoText" class="info">Gunakan WASD/Panah untuk Bergerak | Spasi/Shift untuk Naik/Turun | Tahan Klik Kiri untuk Memutar Kamera</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        // ====================================================================
        // BAGIAN 1: PEMUAT (LOADER) TATA SURYA 2D & ASET 3D
        // ====================================================================
        const loaderCanvas = document.getElementById('sceneCanvas');
        const ctx = loaderCanvas.getContext('2d');

        let width, height;
        let stars2D = [];
        const numStars2D = 500;
        let time = 0;
        let loadingProgress = 0;
        let animationState = 'loading'; // 'loading', 'loaded', 'warping', 'faded'
        let warpFactor = 0;

        let asteroidGeometry = null;
        let asteroidBoundingSphere = null; 
        let assetsLoaded = false; 

        // Objek untuk mengontrol animasi kemunculan via GSAP
        const appearUniforms = {
            progress: { value: 0.0 }
        };

        const sun = { name: 'Sun', color: 'rgba(255, 223, 100, 1)', radius: 25, originalRadius: 25, glow: 'rgba(255, 200, 0, 0.5)', shadowBlur: 20 };
        const planets = [
            { name: 'Mercury', color: '#B5A7A2', radius: 4, orbitRadius: 60, speed: 0.02 },
            { name: 'Venus', color: '#E8B36F', radius: 7, orbitRadius: 90, speed: 0.015 },
            { name: 'Earth', color: '#6B93D6', radius: 8, orbitRadius: 130, speed: 0.01 },
            { name: 'Mars', color: '#C1440E', radius: 6, orbitRadius: 180, speed: 0.008 },
            { name: 'Jupiter', color: '#D8CA9D', radius: 15, orbitRadius: 240, speed: 0.005 },
            { name: 'Saturn', color: '#C7A585', radius: 12, orbitRadius: 310, speed: 0.003, ring: true },
            { name: 'Uranus', color: '#A9D0F5', radius: 10, orbitRadius: 370, speed: 0.002 },
            { name: 'Neptune', color: '#3F5EAB', radius: 10, orbitRadius: 430, speed: 0.001 },
        ];
        planets.forEach(p => {
            p.originalOrbitRadius = p.orbitRadius;
            p.originalSpeed = p.speed;
            p.ellipseFactor = 1.0; 
        });

        let particles = []; // Array untuk partikel ledakan
        let shockwave = { radius: 0, alpha: 0, lineWidth: 0 }; // Objek untuk shockwave
        
        let mainStarfall = null;
        let spiralStarfalls = [];
        const numSpiralStars = 5;
        
        const iconPaths = ["M0,-20 Q15,-15 10,0 Q5,15 0,20 Q-5,15 -10,0 Q-15,-15 0,-20 Z M0,-10 Q5,-5 0,0 Q-5,-5 0,-10 Z","M-15,5 Q-5,15 0,5 Q5,-5 -5,-15 M15,5 Q5,15 0,5 Q-5,-5 5,-15","M0,-17.5 L15,2.5 L0,7.5 L-15,2.5 Z M-8,-2.5 L0,17.5 L8,-2.5","M-2.5,15 A15,15 0 0,0 15,-2.5 M-15,2.5 A10,10 0 0,1 2.5,-15 M-10,-10 L5,5","M0,-17.5 C15,-7.5 8,17.5 0,12.5 C-8,17.5 -15,-7.5 0,-17.5 Z","M0,-20 L0,20 M-15,-10 L15,10 M-15,10 L15,-10 M-9,-17 L9,17 M-9,17 L9,-17","M0,-20 L17,0 L0,20 L-17,0 Z M0,-10 L8.5,0 L0,10 L-8.5,0 Z","M0,0 A13,13 0 1,0 0,1 M-13,0 L13,0 M0,-15 L0,15","M-13,-13 L13,13 M-13,13 L13,-13 M0,-20 L0,20"];
        
        const manager = new THREE.LoadingManager();
        manager.onLoad = function ( ) {
            console.log( 'Loading complete!');
            assetsLoaded = true;
        };

        function preloadAssets() {
            const loader = new OBJLoader(manager);
            loader.load( 'Asteroids.OBJ',
                (object) => {
                    let originalMesh;
                    object.traverse((child) => { if (child.isMesh) { originalMesh = child; } });
                    if (originalMesh) {
                        const geometry = originalMesh.geometry;
                        geometry.computeBoundingSphere();
                        geometry.boundingSphere.radius *= 0.85; 
                        asteroidGeometry = geometry;
                        asteroidBoundingSphere = geometry.boundingSphere.clone();
                    } else {
                        asteroidGeometry = new THREE.SphereGeometry(2, 8, 8);
                        asteroidGeometry.computeBoundingSphere();
                        asteroidBoundingSphere = asteroidGeometry.boundingSphere.clone();
                    }
                }, undefined, (error) => { 
                    console.error('Gagal memuat Asteroids.OBJ', error);
                    asteroidGeometry = new THREE.SphereGeometry(2, 8, 8);
                    asteroidGeometry.computeBoundingSphere();
                    asteroidBoundingSphere = asteroidGeometry.boundingSphere.clone();
                }
            );
        }

        function setupLoader() { width = loaderCanvas.width = window.innerWidth; height = loaderCanvas.height = window.innerHeight; create2DStars(); createStarfall(); loaderCanvas.addEventListener('click', handleLoaderClick); loaderCanvas.addEventListener('mousemove', handleLoaderMouseMove); }
        function create2DStars() { stars2D = []; for (let i = 0; i < numStars2D; i++) { stars2D.push({ x: Math.random() * width, y: Math.random() * height, radius: Math.random() * 1.5 + 0.5, alpha: Math.random(), twinkleSpeed: Math.random() * 0.03 + 0.01 }); } }
        function draw2DStars() { const centerX = width/2, centerY = height/2; for(const star of stars2D){ if(animationState==='warping'){ const dx=star.x-centerX, dy=star.y-centerY, endX=star.x+dx*warpFactor*0.5, endY=star.y+dy*warpFactor*0.5; ctx.beginPath(); ctx.moveTo(star.x,star.y); ctx.lineTo(endX,endY); ctx.strokeStyle=`rgba(255,255,255,${1-warpFactor})`; ctx.lineWidth=star.radius; ctx.stroke(); }else{ star.alpha=Math.abs(Math.sin(time*star.twinkleSpeed)); ctx.beginPath(); ctx.arc(star.x,star.y,star.radius,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,${star.alpha})`; ctx.fill(); }}}
        
        function createStarfall() {
            const angle = Math.random() * Math.PI * 2;
            const startX = width / 2 - Math.cos(angle) * Math.max(width, height);
            const startY = height / 2 - Math.sin(angle) * Math.max(width, height);

            mainStarfall = {
                x: startX,
                y: startY,
                angle: angle,
                speed: 8 + Math.random() * 4,
                trail: [],
                radius: 2.5
            };

            spiralStarfalls = [];
            for (let i = 0; i < numSpiralStars; i++) {
                spiralStarfalls.push({
                    angleOffset: (Math.PI * 2 / numSpiralStars) * i,
                    radius: 1,
                    orbitRadius: 20 + Math.random() * 15,
                    orbitSpeed: 0.05 + Math.random() * 0.05,
                    trail: []
                });
            }
        }

        function updateStarfall() {
            if (!mainStarfall) return;

            // Update main starfall
            mainStarfall.x += Math.cos(mainStarfall.angle) * mainStarfall.speed;
            mainStarfall.y += Math.sin(mainStarfall.angle) * mainStarfall.speed;
            mainStarfall.trail.unshift({ x: mainStarfall.x, y: mainStarfall.y });
            if (mainStarfall.trail.length > 60) {
                mainStarfall.trail.pop();
            }

            // Update spiral starfalls
            spiralStarfalls.forEach(star => {
                const angle = star.angleOffset + time * star.orbitSpeed;
                const x = mainStarfall.x + Math.cos(angle) * star.orbitRadius;
                const y = mainStarfall.y + Math.sin(angle) * star.orbitRadius;
                star.trail.unshift({ x: x, y: y });
                if (star.trail.length > 30) {
                    star.trail.pop();
                }
            });
            
            // Reset if out of bounds
            const margin = 200;
            if (mainStarfall.x < -margin || mainStarfall.x > width + margin || mainStarfall.y < -margin || mainStarfall.y > height + margin) {
                createStarfall();
            }
        }

        function drawStarfall() {
            if (!mainStarfall || mainStarfall.trail.length < 2) return;

            const drawTrail = (star) => {
                if (star.trail.length < 2) return;
                const head = star.trail[0];
                const tail = star.trail[star.trail.length - 1];

                const gradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.beginPath();
                ctx.moveTo(star.trail[0].x, star.trail[0].y);
                for (let i = 1; i < star.trail.length; i++) {
                    ctx.lineWidth = star.radius * (1 - i / star.trail.length) * 2;
                    ctx.lineTo(star.trail[i].x, star.trail[i].y);
                }
                ctx.strokeStyle = gradient;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(head.x, head.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.fill();
            };
            
            drawTrail(mainStarfall);
            spiralStarfalls.forEach(drawTrail);
        }
        
        function drawSolarSystem() { 
            ctx.save(); 
            ctx.translate(width/2, height/2-50); 
            if(animationState!=='warping'){
                ctx.strokeStyle=`rgba(255,255,255,0.1)`; 
                ctx.lineWidth=1; 
                planets.forEach((p,i)=>{
                    if(loadingProgress > (i+1)*(100/9)){
                        ctx.beginPath();
                        ctx.ellipse(0,0,p.orbitRadius, p.orbitRadius / p.ellipseFactor ,0,0,2*Math.PI); 
                        ctx.stroke()
                    }
                })
            } 
            ctx.shadowBlur = sun.shadowBlur;
            ctx.shadowColor=sun.glow; 
            ctx.fillStyle=sun.color; 
            ctx.beginPath(); 
            ctx.arc(0,0,sun.radius,0,2*Math.PI); 
            ctx.fill(); 
            ctx.shadowBlur=0; 
            planets.forEach((p,i)=>{
                if((loadingProgress > (i+1)*(100/9)) || animationState !== 'loading'){
                    const angle=time*p.speed; 
                    let x=p.orbitRadius*Math.cos(angle), 
                        y=p.orbitRadius*Math.sin(angle) / p.ellipseFactor,
                        radius=p.radius; 
                    ctx.globalAlpha=1; 
                    ctx.fillStyle=p.color; 
                    ctx.beginPath(); 
                    ctx.arc(x,y,radius,0,2*Math.PI); 
                    ctx.fill(); 
                    if(p.ring){
                        ctx.strokeStyle=p.color; 
                        ctx.lineWidth=2; 
                        ctx.beginPath(); 
                        ctx.ellipse(x,y,radius*2,radius*0.5,Math.PI/4,0,2*Math.PI); 
                        ctx.stroke()
                    }
                }
            }); 
            ctx.globalAlpha=1; 
            ctx.restore(); 
        }

        function drawParticles() {
            if (particles.length === 0) return;
            ctx.save();
            ctx.translate(width / 2, height / 2 - 50);
            particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }

        function drawShockwave() {
            if (shockwave.alpha <= 0) return;
            ctx.save();
            ctx.translate(width / 2, height / 2 - 50);
            ctx.beginPath();
            ctx.arc(0, 0, shockwave.radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 223, 100, ${shockwave.alpha})`;
            ctx.lineWidth = shockwave.lineWidth;
            ctx.stroke();
            ctx.restore();
        }

        function createExplosion(centerX, centerY, color, count, speedRange) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (speedRange[1] - speedRange[0]) + speedRange[0];
                const particle = {
                    x: centerX,
                    y: centerY,
                    radius: Math.random() * 2.5 + 1,
                    alpha: 1,
                    color: color
                };
                particles.push(particle);

                gsap.to(particle, {
                    x: centerX + Math.cos(angle) * speed,
                    y: centerY + Math.sin(angle) * speed,
                    alpha: 0,
                    duration: 1.5,
                    ease: 'power3.out',
                    delay: Math.random() * 0.2
                });
            }
        }

        function drawLoadingIcons() { if(animationState==='warping'||animationState==='faded')return; const iconSize=25, numIcons=9, spacing=30, totalWidth=numIcons*iconSize+(numIcons-1)*spacing; let startX=(width-totalWidth)/2; const y=height-60; iconPaths.forEach((pathString,i)=>{const step=100/numIcons, isActive=loadingProgress>=i*step, activeColor='rgba(255,223,100,1)', inactiveColor='rgba(255,255,255,0.2)'; ctx.save(); let finalX=startX+iconSize/2; if(i===7)finalX+=10; ctx.translate(finalX,y); ctx.scale(0.8,0.8); const path=new Path2D(pathString); ctx.strokeStyle=isActive?activeColor:inactiveColor; ctx.lineWidth=2; ctx.stroke(path); if(isActive){const fillAmount=(loadingProgress-i*step)/step; ctx.save(); ctx.clip(path); ctx.fillStyle=activeColor; ctx.fillRect(-iconSize,iconSize-(fillAmount*iconSize*2),iconSize*2,iconSize*2); ctx.restore()} ctx.restore(); startX+=iconSize+spacing;}); }
        
        let sunPulseAnimation = null;
        function animateLoader() { 
            time += 1; 
            if (animationState === 'loading') {
                if (loadingProgress < 100) {
                    loadingProgress += 0.5;
                } else {
                    loadingProgress = 100;
                    if (assetsLoaded && animationState !== 'loaded') {
                        animationState = 'loaded';
                        sunPulseAnimation = gsap.to(sun, {
                            radius: sun.originalRadius * 1.2,
                            shadowBlur: 40,
                            duration: 2.5,
                            ease: 'sine.inOut',
                            yoyo: true,
                            repeat: -1
                        });
                    }
                }
            } else if (animationState === 'warping') { 
                if (warpFactor < 1) { 
                    warpFactor += 0.02; 
                } else { 
                    warpFactor = 1; 
                    animationState = 'faded'; 
                    transitionToMainScene(); 
                    return; 
                } 
            } 
            ctx.clearRect(0, 0, width, height); 
            draw2DStars(); 
            if (animationState !== 'warping' && animationState !== 'faded') {
                updateStarfall();
                drawStarfall();
            }
            drawSolarSystem(); 
            drawParticles();
            drawShockwave();
            drawLoadingIcons(); 
            requestAnimationFrame(animateLoader); 
        }

        function handleLoaderClick(e) { 
            if(animationState!=='loaded') return; 
            
            const rect=loaderCanvas.getBoundingClientRect(), mouseX=e.clientX-rect.left, mouseY=e.clientY-rect.top, sunScreenX=width/2, sunScreenY=height/2-50, distance=Math.sqrt((mouseX-sunScreenX)**2+(mouseY-sunScreenY)**2); 
            
            if(distance < sun.radius + 20) {
                if (sunPulseAnimation) sunPulseAnimation.kill();
                
                createExplosion(0, 0, sun.color, 400, [100, 400]);
                gsap.to(sun, { radius: 0, shadowBlur: 0, duration: 0.1 });
                
                shockwave.radius = 0;
                shockwave.alpha = 1;
                shockwave.lineWidth = 15;
                gsap.to(shockwave, {
                    radius: 400,
                    alpha: 0,
                    lineWidth: 0,
                    duration: 0.7,
                    ease: 'power2.out'
                });

                planets.forEach((p, i) => {
                    const angle = time * p.speed;
                    const currentX = p.orbitRadius * Math.cos(angle);
                    const currentY = p.orbitRadius * Math.sin(angle) / p.ellipseFactor;

                    createExplosion(currentX, currentY, p.color, 70, [80, 150]); 
                    
                    gsap.to(p, { radius: 0, duration: 0.1, delay: i * 0.03 });
                });

                setTimeout(() => {
                    animationState = 'warping';
                }, 500);
            }
        }
        
        let isMouseOverSun = false;
        function handleLoaderMouseMove(e) { 
            if(animationState!=='loaded'){
                loaderCanvas.style.cursor='default';
                return;
            }
            const rect=loaderCanvas.getBoundingClientRect(), mouseX=e.clientX-rect.left, mouseY=e.clientY-rect.top, sunScreenX=width/2, sunScreenY=height/2-50, distance=Math.sqrt((mouseX-sunScreenX)**2+(mouseY-sunScreenY)**2); 
            
            if(distance < sun.radius + 20){
                loaderCanvas.style.cursor='pointer';
                if(!isMouseOverSun){
                    isMouseOverSun = true;
                    planets.forEach((p, i) => {
                        gsap.to(p, {
                            orbitRadius: p.originalOrbitRadius * 0.4 + 30,
                            speed: p.originalSpeed * 4,
                            ellipseFactor: 2.0,
                            duration: 0.8,
                            ease: 'power3.out',
                            delay: i * 0.05
                        });
                    });
                }
            } else {
                loaderCanvas.style.cursor='default';
                if(isMouseOverSun){
                    isMouseOverSun = false;
                     planets.forEach((p, i) => {
                        gsap.to(p, {
                            orbitRadius: p.originalOrbitRadius,
                            speed: p.originalSpeed,
                            ellipseFactor: 1.0,
                            duration: 1.2,
                            ease: 'power3.inOut',
                            delay: i * 0.05
                        });
                    });
                }
            }
        }
        
        preloadAssets();
        setupLoader();
        animateLoader();

        // ====================================================================
        // BAGIAN 2: SCENE 3D
        // ====================================================================
        let scene, camera, renderer, plane, clock, cameraPivot, asteroidField;
        const starSystems = [];
        const asteroidData = [];
        const keysPressed = {};
        const planeVelocity = new THREE.Vector3(0, 0, 0); 
        const moveSpeed = 50;
        const collisionNormal = new THREE.Vector3();
        const reflectionVector = new THREE.Vector3();

        let starfallGroup, mainStarfall3D, spiralStarfalls3D = [];
        const starfallColors = [new THREE.Color(0x89CFF0), new THREE.Color(0xFFD700), new THREE.Color(0xFFFFFF), new THREE.Color(0xFF6347), new THREE.Color(0x98FF98)];
        const MAX_TRAIL_POINTS = 50;
        
        let isMouseDown3D = false;
        let previousMousePosition = { x: 0, y: 0 };
        let canControlUFO = false;

        function applyAppearShader(material, topY = 50.0, range = 100.0) {
            material.transparent = true;
            material.onBeforeCompile = (shader) => {
                shader.uniforms.u_appear_progress = appearUniforms.progress;
                shader.uniforms.u_effect_top_y = { value: topY };
                shader.uniforms.u_effect_range = { value: range };
                
                shader.vertexShader = 'varying vec3 vWorldPosition;\n' + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <worldpos_vertex>',
                    `#include <worldpos_vertex>
                     vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;`
                );

                shader.fragmentShader = `
                    uniform float u_appear_progress;
                    uniform float u_effect_top_y;
                    uniform float u_effect_range;
                    varying vec3 vWorldPosition;
                \n` + shader.fragmentShader;

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <dithering_fragment>',
                    `#include <dithering_fragment>
                    
                    if (u_appear_progress < 1.0) {
                        float currentYThreshold = u_effect_top_y - (u_effect_range * u_appear_progress);
                        
                        float fade = smoothstep(
                            currentYThreshold,
                            currentYThreshold + 15.0, 
                            vWorldPosition.y
                        );

                        if (fade < 0.01) discard;
                        gl_FragColor.a *= fade;
                    }
                    `
                );
            };
        }

        function transitionToMainScene() {
            document.getElementById('sceneCanvas').style.display = 'none';
            const mainCanvas = document.getElementById('mainSceneCanvas');
            mainCanvas.style.display = 'block';
            document.getElementById('infoText').style.display = 'block';
            initMainScene(mainCanvas);
        }

        function initMainScene(canvas) {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0b0217, 100, 500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraPivot = new THREE.Group();
            scene.add(cameraPivot);
            cameraPivot.add(camera);
            camera.position.set(0, 5, 15);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0b0217);
            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 50, 50);
            scene.add(dirLight);
            plane = createUFO();
            scene.add(plane);
            
            asteroidField = new THREE.Group();
            scene.add(asteroidField);

            create3DStars();
            createAsteroidField();
            create3DStarfall(); 
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousedown', (e) => handleMouseDown3D(e));
            canvas.addEventListener('mouseup', (e) => handleMouseUp3D(e));
            canvas.addEventListener('mousemove', (e) => handleMouseMove3D(e));
            canvas.addEventListener('mouseleave', (e) => handleMouseUp3D(e));
            
            gsap.to(appearUniforms.progress, {
                value: 1.0,
                duration: 4.0,
                ease: 'power2.out',
                onComplete: () => {
                    canControlUFO = true;
                }
            });

            animateMainScene();
        }

        function createUFO() {
            const ufoGroup = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });
            const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x99ddff, roughness: 0.1, transparent: true, opacity: 0.6 });
            
            applyAppearShader(bodyMat, 10.0, 20.0);
            applyAppearShader(cockpitMat, 10.0, 20.0);

            const saucerGeo = new THREE.CylinderGeometry(4, 4, 1, 32);
            const saucer = new THREE.Mesh(saucerGeo, bodyMat);
            saucer.scale.y = 0.5;
            ufoGroup.add(saucer);
            const cockpitGeo = new THREE.SphereGeometry(2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.y = 0.25;
            ufoGroup.add(cockpit);
            const bottomGeo = new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, Math.PI/2, Math.PI / 2);
            const bottom = new THREE.Mesh(bottomGeo, bodyMat); 
            bottom.position.y = -0.25;
            ufoGroup.add(bottom);
            return ufoGroup;
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.7)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function create3DStars() {
            const createStarLayer = (count, size, hueRange) => {
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({ size: size, sizeAttenuation: true, transparent: true, alphaTest: 0.5, map: createStarTexture(), vertexColors: true });
                const starVertices = [], starColors = [];
                const [hueStart, hueEnd] = hueRange, hueSpan = hueEnd - hueStart;
                for (let i = 0; i < count; i++) {
                    const x = (Math.random() - 0.5) * 2000;
                    const y = (Math.random() - 0.5) * 2000;
                    const z = (Math.random() - 0.5) * 2000;
                    starVertices.push(x, y, z);
                    const color = new THREE.Color();
                    color.setHSL(hueStart + Math.random() * hueSpan, 0.8, 0.7);
                    starColors.push(color.r, color.g, color.b);
                }
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                starSystems.push(stars);
            };
            createStarLayer(200000, 0.5, [0.5, 0.7]);
            createStarLayer(150000, 1.0, [0.0, 0.15]);
            createStarLayer(100000, 1.5, [0.16, 0.3]);
            createStarLayer(50000, 2.0, [0.7, 0.9]);
        }
        
        function create3DStarfall() {
            starfallGroup = new THREE.Group();
            scene.add(starfallGroup);

            const createTrail = () => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(MAX_TRAIL_POINTS * 3);
                const colors = new Float32Array(MAX_TRAIL_POINTS * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setDrawRange(0, 0);

                const material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
                const trailLine = new THREE.Line(geometry, material);
                return trailLine;
            };

            const mainGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const mainMaterial = new THREE.MeshBasicMaterial({ blending: THREE.AdditiveBlending });
            mainStarfall3D = new THREE.Mesh(mainGeometry, mainMaterial);
            mainStarfall3D.userData.trail = createTrail();
            mainStarfall3D.userData.trailPoints = [];
            scene.add(mainStarfall3D.userData.trail);
            
            const mainLight = new THREE.PointLight(0xffffff, 1.5, 50);
            mainStarfall3D.add(mainLight);
            starfallGroup.add(mainStarfall3D);

            const numSpiral = 6;
            const spiralGeometry = new THREE.SphereGeometry(0.2, 12, 12);
            for (let i = 0; i < numSpiral; i++) {
                const spiralMaterial = new THREE.MeshBasicMaterial({ blending: THREE.AdditiveBlending });
                const spiralStar = new THREE.Mesh(spiralGeometry, spiralMaterial);
                const angle = (i / numSpiral) * Math.PI * 2;
                const orbitRadius = 7 + Math.random() * 3;
                
                spiralStar.position.set(Math.cos(angle) * orbitRadius, 0, Math.sin(angle) * orbitRadius);
                spiralStar.userData.angle = angle;
                spiralStar.userData.orbitRadius = orbitRadius;
                spiralStar.userData.speed = 2.0 + Math.random() * 1.0;
                spiralStar.userData.trail = createTrail();
                spiralStar.userData.trailPoints = [];

                spiralStarfalls3D.push(spiralStar);
                starfallGroup.add(spiralStar);
                scene.add(spiralStar.userData.trail);
            }
            
            resetStarfallPosition();
        }

        function resetStarfallPosition() {
            const startX = plane.position.x + (Math.random() - 0.5) * 400;
            const startY = plane.position.y + 200 + Math.random() * 100;
            const startZ = plane.position.z + (Math.random() - 0.5) * 400;
            starfallGroup.position.set(startX, startY, startZ);

            const endX = plane.position.x + (Math.random() - 0.5) * 200;
            const endY = plane.position.y - 150;
            const endZ = plane.position.z + (Math.random() - 0.5) * 200;
            const direction = new THREE.Vector3(endX, endY, endZ).sub(starfallGroup.position).normalize();
            starfallGroup.userData.velocity = direction.multiplyScalar(3 + Math.random() * 2);
            
            const mainColor = starfallColors[Math.floor(Math.random() * starfallColors.length)];
            mainStarfall3D.material.color.set(mainColor);
            mainStarfall3D.children[0].color.set(mainColor); 
            mainStarfall3D.userData.trailPoints = [];
            mainStarfall3D.userData.trail.geometry.setDrawRange(0, 0);

            spiralStarfalls3D.forEach(star => {
                star.material.color.set(starfallColors[Math.floor(Math.random() * starfallColors.length)]);
                star.userData.trailPoints = [];
                star.userData.trail.geometry.setDrawRange(0, 0);
            });

            const mainLight = mainStarfall3D.children[0];
            gsap.fromTo(mainLight, { intensity: 0 }, { intensity: 5, duration: 0.3, yoyo: true, repeat: 1, ease: 'power2.inOut' });
        }
        
        function update3DStarfall(delta) {
            if (!starfallGroup || !starfallGroup.userData.velocity) return;

            starfallGroup.position.add(starfallGroup.userData.velocity.clone().multiplyScalar(delta * 60));

            const updateStarAndTrail = (star, maxLength) => {
                const trail = star.userData.trail;
                const trailPoints = star.userData.trailPoints;
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                
                trailPoints.push(worldPos.clone());
                if (trailPoints.length > maxLength) {
                    trailPoints.shift();
                }

                const positions = trail.geometry.attributes.position.array;
                const colors = trail.geometry.attributes.color.array;
                
                for(let i = 0; i < trailPoints.length; i++) {
                    const point = trailPoints[i];
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;

                    const fade = i / trailPoints.length;
                    const starColor = star.material.color;
                    colors[i * 3] = starColor.r * fade;
                    colors[i * 3 + 1] = starColor.g * fade;
                    colors[i * 3 + 2] = starColor.b * fade;
                }

                trail.geometry.attributes.position.needsUpdate = true;
                trail.geometry.attributes.color.needsUpdate = true;
                trail.geometry.setDrawRange(0, trailPoints.length);
            };

            updateStarAndTrail(mainStarfall3D, MAX_TRAIL_POINTS);

            spiralStarfalls3D.forEach(star => {
                star.userData.angle += star.userData.speed * delta;
                star.position.x = Math.cos(star.userData.angle) * star.userData.orbitRadius;
                star.position.z = Math.sin(star.userData.angle) * star.userData.orbitRadius;
                star.position.y = Math.sin(star.userData.angle * 2.5) * 1.5;
                updateStarAndTrail(star, MAX_TRAIL_POINTS / 2);
            });

            if (starfallGroup.position.y < plane.position.y - 200) {
                resetStarfallPosition();
            }
        }
        
        function setupAsteroids(geometry, boundingSphere) {
            const material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.2 });
            
            applyAppearShader(material, 500.0, 1000.0);

            const count = 100;
            const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();
            const baseRadius = boundingSphere.radius;
            const centerOffset = boundingSphere.center;

            for (let i = 0; i < count; i++) {
                dummy.position.x = (Math.random() - 0.5) * 1000;
                dummy.position.y = (Math.random() - 0.5) * 1000;
                dummy.position.z = (Math.random() - 0.5) * 1000;
                dummy.rotation.x = Math.random() * 2 * Math.PI;
                dummy.rotation.y = Math.random() * 2 * Math.PI;
                dummy.rotation.z = Math.random() * 2 * Math.PI;
                const scale = Math.random() * 3 + 2.0;
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
                const actualCenter = centerOffset.clone().applyMatrix4(dummy.matrix);
                asteroidData.push({ position: actualCenter, radius: baseRadius * scale });
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            asteroidField.add(instancedMesh);
        }

        function createAsteroidField() {
            if (asteroidGeometry && asteroidBoundingSphere) {
                setupAsteroids(asteroidGeometry, asteroidBoundingSphere);
            } else {
                console.error("Geometri asteroid tidak dimuat sebelum membuat scene 3D.");
                const fallbackGeometry = new THREE.SphereGeometry(2, 8, 8);
                fallbackGeometry.computeBoundingSphere();
                setupAsteroids(fallbackGeometry, fallbackGeometry.boundingSphere.clone());
            }
        }
        
        function checkCollision(nextPosition) {
            if (!asteroidField) return null;
            const ufoRadius = 4;
            const worldToLocalMatrix = asteroidField.matrixWorld.clone().invert();
            const localUfoPosition = nextPosition.clone().applyMatrix4(worldToLocalMatrix);

            for (const asteroid of asteroidData) {
                if (localUfoPosition.distanceTo(asteroid.position) < ufoRadius + asteroid.radius) {
                    return asteroid;
                }
            }
            return null;
        }

        function handleKeyDown(event) { keysPressed[event.key.toLowerCase()] = true; }
        function handleKeyUp(event) { keysPressed[event.key.toLowerCase()] = false; }
        
        function handleMouseDown3D(event) {
            if (event.button === 0) {
                isMouseDown3D = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }
        function handleMouseUp3D(event) {
             if (event.button === 0) {
                isMouseDown3D = false;
            }
        }
        
        function handleMouseMove3D(event) {
            if (!isMouseDown3D) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            const yawAngle = -deltaX * 0.005;
            cameraPivot.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), yawAngle);
            
            const pitchAngle = -deltaY * 0.005;
            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(cameraPivot.quaternion);
            cameraPivot.rotateOnWorldAxis(rightVector, pitchAngle);

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function animateMainScene() {
            requestAnimationFrame(animateMainScene);
            const delta = clock.getDelta();
            
            update3DStarfall(delta);
            
            const localTargetVelocity = new THREE.Vector3();
            if(canControlUFO) {
                if (keysPressed['w'] || keysPressed['arrowup']) { localTargetVelocity.z = -1; }
                if (keysPressed['s'] || keysPressed['arrowdown']) { localTargetVelocity.z = 1; }
                if (keysPressed['a'] || keysPressed['arrowleft']) { localTargetVelocity.x = -1; }
                if (keysPressed['d'] || keysPressed['arrowright']) { localTargetVelocity.x = 1; }
                if (keysPressed[' ']) { localTargetVelocity.y = 1; }
                if (keysPressed['shift']) { localTargetVelocity.y = -1; }
            }

            planeVelocity.lerp(localTargetVelocity, 0.1);

            const baseQuaternion = new THREE.Quaternion().setFromEuler(cameraPivot.rotation);

            const bankAngle = planeVelocity.x * -0.3;
            const pitchAngle = planeVelocity.z * 0.3;
            const verticalPitch = planeVelocity.y * 0.3;
            const bankQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), bankAngle);
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchAngle + verticalPitch);

            const finalQuaternion = new THREE.Quaternion().copy(baseQuaternion).multiply(pitchQuat).multiply(bankQuat);
            plane.quaternion.slerp(finalQuaternion, delta * 15);

            const moveVector = planeVelocity.clone()
                .applyQuaternion(plane.quaternion)
                .multiplyScalar(delta * moveSpeed);
            
            const collisionObject = checkCollision(plane.position.clone().add(moveVector));

            if (collisionObject) {
                const worldAsteroidPosition = collisionObject.position.clone().applyMatrix4(asteroidField.matrixWorld);
                const ufoRadius = 4;
                const penetration = (ufoRadius + collisionObject.radius) - plane.position.distanceTo(worldAsteroidPosition);
                if (penetration > 0) {
                    const correction = new THREE.Vector3().subVectors(plane.position, worldAsteroidPosition).normalize().multiplyScalar(penetration);
                    plane.position.add(correction);
                }
                collisionNormal.subVectors(plane.position, worldAsteroidPosition).normalize();
                const dot = moveVector.dot(collisionNormal);
                reflectionVector.copy(collisionNormal).multiplyScalar(dot);
                moveVector.sub(reflectionVector);
                plane.position.add(moveVector);
            } else {
                plane.position.add(moveVector);
            }
            
            starSystems.forEach((stars, index) => {
                stars.rotation.y += 0.0001 * (index + 1);
                stars.rotation.x += 0.00005 * (index + 1);
            });
            
            if (asteroidField) {
                asteroidField.rotation.y += 0.0002;
                asteroidField.rotation.x += 0.0001;
            }
            
            cameraPivot.position.lerp(plane.position, 0.1);
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

