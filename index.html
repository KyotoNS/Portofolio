<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Flight</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0b0217;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
        }
        canvas {    
            display: block;
            cursor: default;
        }
        #mainSceneCanvas {
            display: none; /* Awalnya disembunyikan */
        }
        .info {
            position: absolute;
            top: 20px;
            width: 100%;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: none; /* Awalnya disembunyikan */
        }
    </style>
</head>
<body>
    <canvas id="sceneCanvas"></canvas>
    <canvas id="mainSceneCanvas"></canvas>
    <div id="infoText" class="info">Gunakan WASD/Panah untuk Bergerak | Spasi/Shift untuk Naik/Turun | Tahan Klik Kiri untuk Memutar Kamera</div>

    <!-- Import Map untuk Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        // ====================================================================
        // BAGIAN 1: PEMUAT (LOADER) TATA SURYA 2D & ASET 3D
        // ====================================================================
        const loaderCanvas = document.getElementById('sceneCanvas');
        const ctx = loaderCanvas.getContext('2d');

        let width, height;
        let stars2D = [];
        const numStars2D = 500;
        let time = 0;
        let loadingProgress = 0;
        let animationState = 'loading'; // 'loading', 'loaded', 'warping', 'faded'
        let warpFactor = 0;

        // Variabel untuk menyimpan aset yang sudah dimuat dan status pemuatan
        let asteroidGeometry = null;
        let asteroidBoundingSphere = null; 
        let assetsLoaded = false; 

        const sun = { name: 'Sun', color: 'rgba(255, 223, 100, 1)', radius: 25, glow: 'rgba(255, 200, 0, 0.5)' };
        const planets = [
            { name: 'Mercury', color: '#B5A7A2', radius: 4, orbitRadius: 60, speed: 0.02 },
            { name: 'Venus', color: '#E8B36F', radius: 7, orbitRadius: 90, speed: 0.015 },
            { name: 'Earth', color: '#6B93D6', radius: 8, orbitRadius: 130, speed: 0.01 },
            { name: 'Mars', color: '#C1440E', radius: 6, orbitRadius: 180, speed: 0.008 },
            { name: 'Jupiter', color: '#D8CA9D', radius: 15, orbitRadius: 240, speed: 0.005 },
            { name: 'Saturn', color: '#C7A585', radius: 12, orbitRadius: 310, speed: 0.003, ring: true },
            { name: 'Uranus', color: '#A9D0F5', radius: 10, orbitRadius: 370, speed: 0.002 },
            { name: 'Neptune', color: '#3F5EAB', radius: 10, orbitRadius: 430, speed: 0.001 },
        ];
        const iconPaths = ["M0,-20 Q15,-15 10,0 Q5,15 0,20 Q-5,15 -10,0 Q-15,-15 0,-20 Z M0,-10 Q5,-5 0,0 Q-5,-5 0,-10 Z","M-15,5 Q-5,15 0,5 Q5,-5 -5,-15 M15,5 Q5,15 0,5 Q-5,-5 5,-15","M0,-17.5 L15,2.5 L0,7.5 L-15,2.5 Z M-8,-2.5 L0,17.5 L8,-2.5","M-2.5,15 A15,15 0 0,0 15,-2.5 M-15,2.5 A10,10 0 0,1 2.5,-15 M-10,-10 L5,5","M0,-17.5 C15,-7.5 8,17.5 0,12.5 C-8,17.5 -15,-7.5 0,-17.5 Z","M0,-20 L0,20 M-15,-10 L15,10 M-15,10 L15,-10 M-9,-17 L9,17 M-9,17 L9,-17","M0,-20 L17,0 L0,20 L-17,0 Z M0,-10 L8.5,0 L0,10 L-8.5,0 Z","M0,0 A13,13 0 1,0 0,1 M-13,0 L13,0 M0,-15 L0,15","M-13,-13 L13,13 M-13,13 L13,-13 M0,-20 L0,20"];
        
        const manager = new THREE.LoadingManager();
        manager.onLoad = function ( ) {
            console.log( 'Loading complete!');
            assetsLoaded = true;
        };

        function preloadAssets() {
            const loader = new OBJLoader(manager);
            loader.load( 'Asteroids.OBJ',
                (object) => { // onLoad
                    let originalMesh;
                    object.traverse((child) => { if (child.isMesh) { originalMesh = child; } });
                    if (originalMesh) {
                        const geometry = originalMesh.geometry;
                        geometry.computeBoundingSphere();
                        
                        geometry.boundingSphere.radius *= 0.85; 

                        asteroidGeometry = geometry;
                        asteroidBoundingSphere = geometry.boundingSphere.clone();

                    } else {
                        console.error("Tidak dapat menemukan geometri mesh. Menggunakan fallback.");
                        asteroidGeometry = new THREE.SphereGeometry(2, 8, 8);
                        asteroidGeometry.computeBoundingSphere();
                        asteroidBoundingSphere = asteroidGeometry.boundingSphere.clone();
                    }
                },
                undefined, 
                (error) => { 
                    console.error('Gagal memuat Asteroids.OBJ. Menggunakan fallback.', error);
                    asteroidGeometry = new THREE.SphereGeometry(2, 8, 8);
                    asteroidGeometry.computeBoundingSphere();
                    asteroidBoundingSphere = asteroidGeometry.boundingSphere.clone();
                }
            );
        }

        function setupLoader() { width = loaderCanvas.width = window.innerWidth; height = loaderCanvas.height = window.innerHeight; create2DStars(); loaderCanvas.addEventListener('click', handleLoaderClick); loaderCanvas.addEventListener('mousemove', handleLoaderMouseMove); }
        function create2DStars() { stars2D = []; for (let i = 0; i < numStars2D; i++) { stars2D.push({ x: Math.random() * width, y: Math.random() * height, radius: Math.random() * 1.5 + 0.5, alpha: Math.random(), twinkleSpeed: Math.random() * 0.03 + 0.01 }); } }
        function draw2DStars() { const centerX = width/2, centerY = height/2; for(const star of stars2D){ if(animationState==='warping'){ const dx=star.x-centerX, dy=star.y-centerY, endX=star.x+dx*warpFactor*0.5, endY=star.y+dy*warpFactor*0.5; ctx.beginPath(); ctx.moveTo(star.x,star.y); ctx.lineTo(endX,endY); ctx.strokeStyle=`rgba(255,255,255,${1-warpFactor})`; ctx.lineWidth=star.radius; ctx.stroke(); }else{ star.alpha=Math.abs(Math.sin(time*star.twinkleSpeed)); ctx.beginPath(); ctx.arc(star.x,star.y,star.radius,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,${star.alpha})`; ctx.fill(); }}}
        function drawSolarSystem() { ctx.save(); ctx.translate(width/2,height/2-50); if(animationState!=='warping'){ctx.strokeStyle=`rgba(255,255,255,0.1)`; ctx.lineWidth=1; planets.forEach((p,i)=>{if(loadingProgress>(i+1)*(100/9)){ctx.beginPath();ctx.ellipse(0,0,p.orbitRadius,p.orbitRadius,0,0,2*Math.PI);ctx.stroke()}})} const sunPulse=animationState==='loaded'?Math.sin(time*0.1)*5:0, sunWarpSize=animationState==='warping'?width*warpFactor*1.5:0; ctx.shadowBlur=20+sunPulse+(warpFactor*100); ctx.shadowColor=sun.glow; ctx.fillStyle=sun.color; ctx.beginPath(); ctx.arc(0,0,sun.radius+sunPulse+sunWarpSize,0,2*Math.PI); ctx.fill(); ctx.shadowBlur=0; planets.forEach((p,i)=>{if((loadingProgress>(i+1)*(100/9))||animationState!=='loading'){const angle=time*p.speed; let x=p.orbitRadius*Math.cos(angle), y=p.orbitRadius*Math.sin(angle), radius=p.radius; ctx.globalAlpha=1; if(animationState==='warping'){const warpScale=1+warpFactor*3; x*=warpScale; y*=warpScale; radius*=warpScale; ctx.globalAlpha=1-warpFactor} ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(x,y,radius,0,2*Math.PI); ctx.fill(); if(p.ring){ctx.strokeStyle=p.color; ctx.lineWidth=2*(animationState==='warping'?1+warpFactor*3:1); ctx.beginPath(); ctx.ellipse(x,y,radius*2,radius*0.5,Math.PI/4,0,2*Math.PI); ctx.stroke()}}}); ctx.globalAlpha=1; ctx.restore(); }
        function drawLoadingIcons() { if(animationState==='warping'||animationState==='faded')return; const iconSize=25, numIcons=9, spacing=30, totalWidth=numIcons*iconSize+(numIcons-1)*spacing; let startX=(width-totalWidth)/2; const y=height-60; iconPaths.forEach((pathString,i)=>{const step=100/numIcons, isActive=loadingProgress>=i*step, activeColor='rgba(255,223,100,1)', inactiveColor='rgba(255,255,255,0.2)'; ctx.save(); let finalX=startX+iconSize/2; if(i===7)finalX+=10; ctx.translate(finalX,y); ctx.scale(0.8,0.8); const path=new Path2D(pathString); ctx.strokeStyle=isActive?activeColor:inactiveColor; ctx.lineWidth=2; ctx.stroke(path); if(isActive){const fillAmount=(loadingProgress-i*step)/step; ctx.save(); ctx.clip(path); ctx.fillStyle=activeColor; ctx.fillRect(-iconSize,iconSize-(fillAmount*iconSize*2),iconSize*2,iconSize*2); ctx.restore()} ctx.restore(); startX+=iconSize+spacing;}); }
        
        function animateLoader() { 
            time += 1; 
            if (animationState === 'loading') {
                if (loadingProgress < 100) {
                    loadingProgress += 0.5;
                } else {
                    loadingProgress = 100;
                    if (assetsLoaded) {
                        animationState = 'loaded';
                    }
                }
            } else if (animationState === 'warping') { 
                if (warpFactor < 1) { 
                    warpFactor += 0.01; 
                } else { 
                    warpFactor = 1; 
                    animationState = 'faded'; 
                    transitionToMainScene(); 
                    return; 
                } 
            } 
            ctx.clearRect(0, 0, width, height); 
            draw2DStars(); 
            drawSolarSystem(); 
            drawLoadingIcons(); 
            requestAnimationFrame(animateLoader); 
        }

        function handleLoaderClick(e) { if(animationState!=='loaded')return; const rect=loaderCanvas.getBoundingClientRect(), mouseX=e.clientX-rect.left, mouseY=e.clientY-rect.top, sunScreenX=width/2, sunScreenY=height/2-50, distance=Math.sqrt((mouseX-sunScreenX)**2+(mouseY-sunScreenY)**2); if(distance<sun.radius+10){animationState='warping';} }
        function handleLoaderMouseMove(e) { if(animationState!=='loaded'){loaderCanvas.style.cursor='default';return;} const rect=loaderCanvas.getBoundingClientRect(), mouseX=e.clientX-rect.left, mouseY=e.clientY-rect.top, sunScreenX=width/2, sunScreenY=height/2-50, distance=Math.sqrt((mouseX-sunScreenX)**2+(mouseY-sunScreenY)**2); if(distance<sun.radius+10){loaderCanvas.style.cursor='pointer';}else{loaderCanvas.style.cursor='default';}}
        
        preloadAssets();
        setupLoader();
        animateLoader();

        // ====================================================================
        // BAGIAN 2: SCENE 3D
        // ====================================================================
        let scene, camera, renderer, plane, clock, cameraPivot;
        const starSystems = [];
        const asteroidData = [];
        const keysPressed = {};
        const planeVelocity = new THREE.Vector3(0, 0, 0); // This will now be LOCAL velocity
        const moveSpeed = 50;
        const collisionNormal = new THREE.Vector3();
        const reflectionVector = new THREE.Vector3();

        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        function transitionToMainScene() {
            document.getElementById('sceneCanvas').style.display = 'none';
            const mainCanvas = document.getElementById('mainSceneCanvas');
            mainCanvas.style.display = 'block';
            document.getElementById('infoText').style.display = 'block';
            initMainScene(mainCanvas);
        }

        function initMainScene(canvas) {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0b0217, 100, 500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraPivot = new THREE.Group();
            scene.add(cameraPivot);
            cameraPivot.add(camera);
            camera.position.set(0, 5, 15);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0b0217);
            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 50, 50);
            scene.add(dirLight);
            plane = createUFO();
            scene.add(plane);
            create3DStars();
            createAsteroidField();
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mousemove', handleMouseMove3D);
            canvas.addEventListener('mouseleave', handleMouseUp);
            animateMainScene();
        }

        function createUFO() {
            const ufoGroup = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });
            const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x99ddff, roughness: 0.1, transparent: true, opacity: 0.6 });
            const saucerGeo = new THREE.CylinderGeometry(4, 4, 1, 32);
            const saucer = new THREE.Mesh(saucerGeo, bodyMat);
            saucer.scale.y = 0.5;
            ufoGroup.add(saucer);
            const cockpitGeo = new THREE.SphereGeometry(2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.y = 0.25;
            ufoGroup.add(cockpit);
            const bottomGeo = new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, Math.PI/2, Math.PI / 2);
            const bottom = new THREE.Mesh(bottomGeo, bodyMat);
            bottom.position.y = -0.25;
            ufoGroup.add(bottom);
            return ufoGroup;
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.7)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function create3DStars() {
            const createStarLayer = (count, size, hueRange) => {
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({ size: size, sizeAttenuation: true, transparent: true, alphaTest: 0.5, map: createStarTexture(), vertexColors: true });
                const starVertices = [], starColors = [];
                const [hueStart, hueEnd] = hueRange, hueSpan = hueEnd - hueStart;
                for (let i = 0; i < count; i++) {
                    const x = (Math.random() - 0.5) * 2000;
                    const y = (Math.random() - 0.5) * 2000;
                    const z = (Math.random() - 0.5) * 2000;
                    starVertices.push(x, y, z);
                    const color = new THREE.Color();
                    color.setHSL(hueStart + Math.random() * hueSpan, 0.8, 0.7);
                    starColors.push(color.r, color.g, color.b);
                }
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                starSystems.push(stars);
            };
            createStarLayer(200000, 0.5, [0.5, 0.7]);
            createStarLayer(150000, 1.0, [0.0, 0.15]);
            createStarLayer(100000, 1.5, [0.16, 0.3]);
            createStarLayer(50000, 2.0, [0.7, 0.9]);
        }
        
        function setupAsteroids(geometry, boundingSphere) {
            const material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.2 });
            const count = 100;
            const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();
            const baseRadius = boundingSphere.radius;
            const centerOffset = boundingSphere.center;

            for (let i = 0; i < count; i++) {
                dummy.position.x = (Math.random() - 0.5) * 1000;
                dummy.position.y = (Math.random() - 0.5) * 1000;
                dummy.position.z = (Math.random() - 0.5) * 1000;
                dummy.rotation.x = Math.random() * 2 * Math.PI;
                dummy.rotation.y = Math.random() * 2 * Math.PI;
                dummy.rotation.z = Math.random() * 2 * Math.PI;
                const scale = Math.random() * 3 + 2.0;
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
                const actualCenter = centerOffset.clone().applyMatrix4(dummy.matrix);
                asteroidData.push({ position: actualCenter, radius: baseRadius * scale });
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            scene.add(instancedMesh);
        }

        function createAsteroidField() {
            if (asteroidGeometry && asteroidBoundingSphere) {
                setupAsteroids(asteroidGeometry, asteroidBoundingSphere);
            } else {
                console.error("Geometri asteroid tidak dimuat sebelum membuat scene 3D.");
                const fallbackGeometry = new THREE.SphereGeometry(2, 8, 8);
                fallbackGeometry.computeBoundingSphere();
                setupAsteroids(fallbackGeometry, fallbackGeometry.boundingSphere.clone());
            }
        }
        
        function checkCollision(nextPosition) {
            const ufoRadius = 4;
            for (const asteroid of asteroidData) {
                if (nextPosition.distanceTo(asteroid.position) < ufoRadius + asteroid.radius) {
                    return asteroid;
                }
            }
            return null;
        }

        function handleKeyDown(event) { keysPressed[event.key.toLowerCase()] = true; }
        function handleKeyUp(event) { keysPressed[event.key.toLowerCase()] = false; }
        
        function handleMouseDown(event) {
            if (event.button === 0) {
                isMouseDown = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }
        function handleMouseUp(event) {
             if (event.button === 0) {
                isMouseDown = false;
            }
        }
        function handleMouseMove3D(event) {
            if (!isMouseDown) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cameraPivot.rotation.y -= deltaX * 0.005;
            cameraPivot.rotation.x -= deltaY * 0.005;
            // **PERBAIKAN: Batasan rotasi vertikal dihapus**
            // cameraPivot.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 2, cameraPivot.rotation.x));
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function animateMainScene() {
            requestAnimationFrame(animateMainScene);
            const delta = clock.getDelta();
            
            // Tentukan target kecepatan dalam ruang LOKAL UFO
            const localTargetVelocity = new THREE.Vector3();
            if (keysPressed['w'] || keysPressed['arrowup']) { localTargetVelocity.z = -1; }
            if (keysPressed['s'] || keysPressed['arrowdown']) { localTargetVelocity.z = 1; }
            if (keysPressed['a'] || keysPressed['arrowleft']) { localTargetVelocity.x = -1; }
            if (keysPressed['d'] || keysPressed['arrowright']) { localTargetVelocity.x = 1; }
            if (keysPressed[' ']) { localTargetVelocity.y = 1; }
            if (keysPressed['shift']) { localTargetVelocity.y = -1; }

            // planeVelocity sekarang adalah kecepatan LOKAL yang dimuluskan
            planeVelocity.lerp(localTargetVelocity, 0.1);

            // **LOGIKA ROTASI DAN GERAKAN YANG DIPERBAIKI**
            // 1. Hitung rotasi dasar dari kamera
            const baseQuaternion = new THREE.Quaternion().setFromEuler(cameraPivot.rotation);

            // 2. Hitung rotasi tambahan (banking/pitching) dari kecepatan LOKAL
            const bankAngle = planeVelocity.x * -0.3;
            const pitchAngle = planeVelocity.z * 0.3;
            const verticalPitch = planeVelocity.y * 0.3;
            const bankQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), bankAngle);
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchAngle + verticalPitch);

            // 3. Gabungkan rotasi: dasar * tambahan, dan terapkan ke UFO
            const finalQuaternion = new THREE.Quaternion().copy(baseQuaternion).multiply(pitchQuat).multiply(bankQuat);
            plane.quaternion.slerp(finalQuaternion, delta * 15);

            // 4. Ubah kecepatan lokal menjadi vektor pergerakan di ruang GLOBAL menggunakan rotasi FINAL UFO
            const moveVector = planeVelocity.clone()
                .applyQuaternion(plane.quaternion)
                .multiplyScalar(delta * moveSpeed);
            
            const collisionObject = checkCollision(plane.position.clone().add(moveVector));

            if (collisionObject) {
                const ufoRadius = 4;
                const penetration = (ufoRadius + collisionObject.radius) - plane.position.distanceTo(collisionObject.position);
                if (penetration > 0) {
                    const correction = new THREE.Vector3().subVectors(plane.position, collisionObject.position).normalize().multiplyScalar(penetration);
                    plane.position.add(correction);
                }
                collisionNormal.subVectors(plane.position, collisionObject.position).normalize();
                const dot = moveVector.dot(collisionNormal);
                reflectionVector.copy(collisionNormal).multiplyScalar(dot);
                moveVector.sub(reflectionVector);
                plane.position.add(moveVector);
            } else {
                plane.position.add(moveVector);
            }
            
            starSystems.forEach((stars, index) => {
                stars.rotation.y += 0.0001 * (index + 1);
                stars.rotation.x += 0.00005 * (index + 1);
            });
            
            cameraPivot.position.lerp(plane.position, 0.1);
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

