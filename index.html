<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Loading Screen - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Latar belakang diatur di sini karena canvas akan transparan */
            background: radial-gradient(ellipse at center, #411d65 0%, #231044 60%, #0b0217 100%);
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Three.js akan menggambar di dalam canvas ini -->
    <canvas id="bg"></canvas>

    <!-- Import Three.js dari CDN -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 1. Setup Dasar
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg'),
            alpha: true, // Membuat canvas transparan agar background body terlihat
        });

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        // 2. Pencahayaan
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(8, 15, 10);
        scene.add(directionalLight);
        
        // 3. Membuat Platform Kotak (VILLA DIHAPUS)
        const platformGroup = new THREE.Group();
        const platformMaterial = new THREE.MeshLambertMaterial({ color: 0x009696 }); // Warna yang sama dengan dinding villa sebelumnya
        const platformGeometry = new THREE.BoxGeometry(15, 1, 15); // Lebar, tinggi, kedalaman
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platformGroup.add(platform);
        scene.add(platformGroup);

        // 4. Membuat Bintang
        const numStars = 10000;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }
        const starTexture = createStarTexture();

        const starGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(numStars * 3);
        const randoms = new Float32Array(numStars); 

        for (let i = 0; i < numStars; i++) {
            positions[i * 3 + 0] = (Math.random() - 0.5) * 2000;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
            randoms[i] = Math.random();
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const vertexShader = `
            attribute float aRandom;
            varying float vRandom;
            void main() {
                vRandom = aRandom;
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);
                vec4 viewPosition = viewMatrix * modelPosition;
                gl_Position = projectionMatrix * viewPosition;
                gl_PointSize = 2.5 + aRandom * 1.5;
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform sampler2D uTexture;
            varying float vRandom;
            void main() {
                vec4 textureColor = texture2D(uTexture, gl_PointCoord);
                float twinkle = abs(sin(uTime * (vRandom * 0.5 + 0.2) + vRandom * 10.0));
                gl_FragColor = vec4(textureColor.rgb, textureColor.a * twinkle);
            }
        `;

        const starMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0.0 },
                uTexture: { value: starTexture }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // 5. Animasi
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Animasi platform mengambang
            platformGroup.position.y = Math.sin(elapsedTime * 0.5);
            
            starMaterial.uniforms.uTime.value = elapsedTime;

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

